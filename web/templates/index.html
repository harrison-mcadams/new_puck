<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shot Plot</title>
  <style>
    :root {
      --primary-color: #F74902;
      /* Flyers Orange */
      --primary-hover: #D63E02;
      --bg-color: #f8f9fa;
      --surface-color: #ffffff;
      --text-color: #000000;
      --text-secondary: #444444;
      --border-color: #e0e0e0;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --radius: 8px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
      line-height: 1.5;
    }

    /* Header */
    .app-header {
      background-color: #000000;
      /* Flyers Black */
      color: white;
      padding: 0.8rem 2rem;
      box-shadow: var(--shadow-md);
      border-bottom: 3px solid var(--primary-color);
      /* Orange accent */
    }

    .header-content {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .app-title {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
    }

    .nav-link {
      color: rgba(255, 255, 255, 0.8);
      text-decoration: none;
      margin-left: 1.5rem;
      font-weight: 500;
      transition: color 0.2s;
    }

    .nav-link:hover,
    .nav-link.active {
      color: white;
    }

    /* Main Container */
    .app-container {
      max-width: 1200px;
      margin: 1.5rem auto;
      padding: 0 1rem;
    }

    /* Cards */
    .card {
      background: var(--surface-color);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      margin-bottom: 1.5rem;
      border: 1px solid var(--border-color);
      overflow: visible;
      /* Allow dropdowns to overflow if needed, but we use absolute pos */
    }

    .card-header {
      padding: 0.8rem 1.2rem;
      border-bottom: 1px solid var(--border-color);
      background-color: #fafbfc;
    }

    .card-header h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
    }

    .card-body {
      padding: 1rem;
    }

    /* Form Controls */
    .control-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
      align-items: flex-end;
    }

    .input-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    label {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--text-color);
    }

    select,
    input[type="text"] {
      padding: 0.4rem 0.6rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 0.9rem;
      background-color: white;
      transition: border-color 0.2s;
      height: 36px;
      /* Uniform height */
      box-sizing: border-box;
    }

    select:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.1);
    }

    /* Game State Expandable */
    .game-state-wrapper {
      position: relative;
      height: 36px;
      width: 120px;
    }

    .game-state-select {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      max-height: 36px;
      overflow-y: hidden;
      z-index: 100;
      transition: max-height 0.2s ease, box-shadow 0.2s;
      padding: 0.2rem;
      /* Tighter padding for list */
    }

    .game-state-select:hover,
    .game-state-select:focus {
      max-height: 200px;
      overflow-y: auto;
      box-shadow: var(--shadow-md);
      border-color: var(--primary-color);
    }

    /* Hide scrollbar when collapsed */
    .game-state-select:not(:hover):not(:focus)::-webkit-scrollbar {
      display: none;
    }

    .divider {
      border: 0;
      border-top: 1px solid var(--border-color);
      margin: 1rem 0;
    }

    /* Buttons */
    .btn {
      padding: 0.5rem 1.2rem;
      border: none;
      border-radius: 4px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
      font-size: 0.9rem;
      height: 36px;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background-color: var(--primary-hover);
    }

    .btn-secondary {
      background-color: #e9ecef;
      color: var(--text-color);
    }

    .btn-secondary:hover {
      background-color: #dde2e6;
    }

    .action-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
    }

    /* Plot */
    .plot-container {
      display: flex;
      justify-content: center;
      padding: 0.5rem;
      min-height: 300px;
      align-items: center;
    }

    .plot-container img {
      max-width: 100%;
      height: auto;
      border-radius: 4px;
    }

    .empty-state {
      color: var(--text-secondary);
      font-style: italic;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      .app-header {
        padding: 0.8rem 1rem;
      }

      .header-content {
        flex-direction: column;
        gap: 1rem;
        align-items: stretch;
      }

      .header-content>div {
        justify-content: center;
      }

      .app-title {
        font-size: 1.2rem;
      }

      nav {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
      }

      .nav-link {
        margin-left: 0;
      }

      .app-container {
        margin: 1rem auto;
      }

      .control-group {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
      }

      .input-wrapper {
        width: 100%;
      }

      select,
      input[type="text"],
      .game-state-wrapper {
        width: 100% !important;
        min-width: 0 !important;
      }

      .action-group {
        flex-direction: column-reverse;
        gap: 0.8rem;
      }

      .btn {
        width: 100%;
      }
    }
  </style>
</head>

<body>

  <header class="app-header">
    <div class="header-content">
      <div style="display:flex; align-items:center; gap:1rem;">
        <img src="{{ url_for('static', filename='logo.png') }}" alt="Logo" style="height: 40px; width: auto;">
        <h1 class="app-title">New Puck Analysis</h1>
      </div>
      <nav>
        <a href="{{ url_for('index') }}" class="nav-link active">Games</a>
        <a href="{{ url_for('teams') }}" class="nav-link">Teams</a>
        <a href="{{ url_for('players') }}" class="nav-link">Players</a>
        <a href="{{ url_for('monitor') }}" class="nav-link">Monitor</a>
      </nav>
    </div>
  </header>

  <main class="app-container">
    <form id="replotForm" action="{{ url_for('replot') }}" method="post">

      <!-- Config Card -->
      <div class="card">
        <div class="card-header">
          <h2>Config</h2>
        </div>
        <div class="card-body">

          <!-- Game Selection -->
          <div class="control-group">
            <div class="input-wrapper">
              <label for="team_select">Team</label>
              <select id="team_select" name="team_select" style="min-width:180px;">
                <option value="">-- select team --</option>
              </select>
            </div>
            <div class="input-wrapper">
              <label for="game_select">Game</label>
              <select id="game_select" style="min-width:260px;">
                <option value="">-- select game --</option>
              </select>
            </div>
            <div class="input-wrapper">
              <label for="game_manual">Game ID</label>
              <input type="text" id="game_manual" placeholder="e.g. 2025020196" style="min-width:120px;" />
            </div>
          </div>

          <hr class="divider">

          <!-- Filters -->
          <div class="control-group">

            <!-- Game State (Compact) -->
            <div class="input-wrapper">
              <label for="game_state">Game State</label>
              <div class="game-state-wrapper">
                <select id="game_state" name="game_state" multiple class="game-state-select">
                  <option value="" {% if not metadata or not metadata.current_condition or not
                    metadata.current_condition.get('game_state') %}selected{% endif %}>-- Any --</option>
                  {% if metadata and metadata.game_states %}
                  {% for state in metadata.game_states %}
                  <option value="{{ state }}" {% if metadata.current_condition and state in
                    metadata.current_condition.get('game_state', []) %}selected{% endif %}>{{ state }}</option>
                  {% endfor %}
                  {% else %}
                  <option value="5v5">5v5</option>
                  <option value="5v4">5v4</option>
                  <option value="4v5">4v5</option>
                  <option value="4v4">4v4</option>
                  <option value="3v3">3v3</option>
                  <option value="6v5">6v5</option>
                  <option value="5v6">5v6</option>
                  {% endif %}
                </select>
              </div>
            </div>

            <!-- Net Empty -->
            <div class="input-wrapper">
              <label for="is_net_empty">Net Empty</label>
              <select id="is_net_empty" name="is_net_empty" style="min-width: 80px;">
                <option value="">Any</option>
                <option value="0" {% if metadata and metadata.current_condition and
                  metadata.current_condition.get('is_net_empty')==[0] %}selected{% endif %}>No</option>
                <option value="1" {% if metadata and metadata.current_condition and
                  metadata.current_condition.get('is_net_empty')==[1] %}selected{% endif %}>Yes</option>
              </select>
            </div>

            <!-- Player -->
            <div class="input-wrapper">
              <label for="player_id">Player</label>
              <select id="player_id" name="player_id" style="min-width: 180px;">
                <option value="">Any</option>
                {% if metadata and metadata.players %}
                {% for p in metadata.players %}
                <option value="{{ p.id }}" {% if metadata.current_condition and
                  metadata.current_condition.get('player_id')==p.id %}selected{% endif %}>{{ p.name }}</option>
                {% endfor %}
                {% endif %}
              </select>
            </div>

            <!-- JSON -->
            <div class="input-wrapper">
              <label for="condition" style="color:var(--text-secondary);">Advanced</label>
              <input type="text" id="condition" name="condition" value="" placeholder='JSON'
                style="min-width: 150px;" />
            </div>

          </div>

          <!-- Actions -->
          <div class="action-group">
            <button type="button" onclick="clearFilters()" class="btn btn-secondary">Clear Filters</button>
            <button type="submit" class="btn btn-primary">Update Plot</button>
          </div>

          <input type="hidden" id="game" name="game" value="" />
        </div>
      </div>

      <!-- Viz Card -->
      <div class="card">
        <div class="card-header">
          <h2>Viz</h2>
        </div>
        <div class="card-body plot-container">
          {% if exists %}
          <img src="{{ url_for('analysis_file', filename=img) }}" alt="Shot Plot" />
          {% else %}
          <p class="empty-state">Select a game and click "Update Plot"</p>
          {% endif %}
        </div>
      </div>

    </form>
  </main>


  <script>
    function clearFilters() {
      // Reset Game State to first option (Any)
      const gs = document.getElementById('game_state');
      for (let i = 0; i < gs.options.length; i++) {
        gs.options[i].selected = (i === 0);
      }

      // Reset Net Empty
      document.getElementById('is_net_empty').value = "";

      // Reset Player
      document.getElementById('player_id').value = "";

      // Reset JSON
      document.getElementById('condition').value = "";
    }
  </script>

  <script>
    (function () {
      const teamSelect = document.getElementById('team_select');
      const gameSelect = document.getElementById('game_select');
      const manualInput = document.getElementById('game_manual');
      const hiddenInput = document.getElementById('game');
      const form = document.getElementById('replotForm');

      const FALLBACK_TEAMS = [
        { abbr: 'BOS', name: 'Bruins' },
        { abbr: 'NYR', name: 'Rangers' },
        { abbr: 'PHI', name: 'Flyers' },
        { abbr: 'PIT', name: 'Penguins' },
        { abbr: 'TOR', name: 'Maple Leafs' },
        { abbr: 'CHI', name: 'Blackhawks' }
      ];

      // cache games mapping and teams list in memory
      let gamesByTeam = null;
      let teamsList = null;
      // reverse index: game id -> array of team keys that have this game
      let gamesById = null;

      function clearGames() {
        gameSelect.innerHTML = '<option value="">-- select game --</option>';
      }

      function populateTeamSelect(teams) {
        teamSelect.disabled = true;
        teamSelect.innerHTML = '<option value="">-- select team --</option>';
        clearGames();
        if (!Array.isArray(teams) || teams.length === 0) teams = FALLBACK_TEAMS;
        teams.forEach(t => {
          const opt = document.createElement('option');
          opt.value = (t.abbr || t.abbreviation || t.code || '').toString();
          opt.textContent = `${opt.value} - ${t.name || t.teamName || ''}`;
          teamSelect.appendChild(opt);
        });
        teamSelect.disabled = false;
        try { teamSelect.focus(); } catch (e) { }
      }

      async function loadStaticTeams() {
        try {
          const res = await fetch('/analysis/teams.json?_=' + Date.now());
          if (!res.ok) {
            populateTeamSelect(FALLBACK_TEAMS);
            return;
          }
          const teams = await res.json();
          if (!teams || !Array.isArray(teams) || teams.length === 0) {
            populateTeamSelect(FALLBACK_TEAMS);
            return;
          }
          teamsList = teams; // store for fuzzy name matching later
          populateTeamSelect(teams);
          // ensure games map is loaded so we can safely auto-select a default team
          try { await ensureGamesMap(); } catch (e) { /* ignore */ }
          // now auto-select the default (PHI) and load its games if present
          try {
            const defaultTeam = 'PHI';
            if (Array.from(teamSelect.options).some(o => o.value === defaultTeam)) {
              teamSelect.value = defaultTeam;
              loadGamesForTeam(defaultTeam, true);
            }
          } catch (e) { /* ignore */ }
        } catch (err) {
          console.error('Error loading teams.json:', err);
          populateTeamSelect(FALLBACK_TEAMS);
        }
      }

      async function ensureGamesMap() {
        if (gamesByTeam) return gamesByTeam;
        try {
          const res = await fetch('/analysis/games_by_team.json?_=' + Date.now());
          if (!res.ok) {
            // don't spam logs on minor fetch issues; only show error
            console.error('Could not load games_by_team.json; status=' + res.status);
            gamesByTeam = {};
            return gamesByTeam;
          }
          try {
            gamesByTeam = await res.json();
          } catch (errJson) {
            console.error('Failed to parse games_by_team.json:', errJson);
            gamesByTeam = {};
            return gamesByTeam;
          }
          // build reverse index for quick opponent inference
          try {
            gamesById = {};
            for (const teamKey of Object.keys(gamesByTeam || {})) {
              const list = gamesByTeam[teamKey] || [];
              for (const gg of list) {
                if (!gg) continue;
                const gid = (gg.id != null) ? String(gg.id) : (gg.gamePk != null ? String(gg.gamePk) : (gg.gameId != null ? String(gg.gameId) : null));
                if (!gid) continue;
                if (!gamesById[gid]) gamesById[gid] = [];
                const tku = teamKey.toString().toUpperCase();
                if (gamesById[gid].indexOf(tku) === -1) gamesById[gid].push(tku);
              }
            }
          } catch (e) { /* ignore index build errors */ }
          return gamesByTeam;
        } catch (err) {
          console.error('Error loading games_by_team.json:', err);
          gamesByTeam = {};
          return gamesByTeam;
        }
      }

      async function loadGamesForTeam(team, autoSelectMostRecent = false) {
        clearGames();
        if (!team) return;
        const teamStr = (team || '').toString().trim();
        const teamKeyUpper = teamStr.toUpperCase();
        const map = await ensureGamesMap();
        let games = [];
        try {
          if (map) {
            games = map[teamStr] || map[teamKeyUpper] || map[teamStr.toLowerCase()] || [];
            if ((!games || games.length === 0)) {
              const teamLower = teamStr.toLowerCase();
              for (const k of Object.keys(map)) {
                try {
                  if (!k) continue;
                  const kl = k.toString().toLowerCase();
                  if (kl === teamLower || kl.indexOf(teamLower) !== -1) {
                    games = map[k];
                    break;
                  }
                  const list = map[k] || [];
                  if (Array.isArray(list)) {
                    for (const gg of list) {
                      const lab = (gg && (gg.label || gg.start || '') || '').toString().toLowerCase();
                      if (lab.indexOf(teamLower) !== -1) {
                        games = list;
                        break;
                      }
                    }
                    if (games && games.length) break;
                  }
                } catch (err) { /* ignore per-key errors */ }
              }
            }
          }
        } catch (e) {
          games = [];
        }
        if (!games || !Array.isArray(games) || games.length === 0) {
          try {
            const infoOpt = document.createElement('option');
            infoOpt.disabled = true;
            infoOpt.selected = true;
            const availableKeys = map ? Object.keys(map).slice(0, 12) : [];
            infoOpt.textContent = `No games found for ${teamStr}. Keys checked: ${availableKeys.join(', ')}`;
            gameSelect.appendChild(infoOpt);
          } catch (e) { /* ignore */ }
          return;
        }
        // Sort games chronologically (oldest first) using the 'start' or 'gameDate' field.
        const sortedGames = (games || []).slice().map(gg => ({
          orig: gg,
          startRaw: (gg.start || gg.gameDate || (gg.label || '').split(' - ')[0] || null),
          ts: (function (s) { const t = Date.parse(s); return isNaN(t) ? null : t; })((gg.start || gg.gameDate || (gg.label || '').split(' - ')[0] || null))
        })).sort((a, b) => {
          const ta = a.ts === null ? Infinity : a.ts;
          const tb = b.ts === null ? Infinity : b.ts;
          return ta - tb;
        }).map(x => x.orig);

        // populate the dropdown in chronological order (oldest -> newest)
        sortedGames.forEach(g => {
          const opt = document.createElement('option');
          opt.value = g.id;
          let display = '';
          const lbl = (g.label || '').toString();
          const start = g.start || g.gameDate || '';
          let datePart = '';
          try {
            if (start) {
              const dt = new Date(start);
              if (!isNaN(dt)) {
                const y = dt.getUTCFullYear();
                const m = String(dt.getUTCMonth() + 1).padStart(2, '0');
                const d = String(dt.getUTCDate()).padStart(2, '0');
                datePart = `${y}-${m}-${d}`;
              }
            }
          } catch (e) { datePart = ''; }

          let opp = '';
          let venue = '';
          try {
            const mopp = lbl.match(/vs\s+([^\s()\-]+)/i);
            if (mopp) opp = mopp[1].trim();
            const mvenue = lbl.match(/\((home|away)\)/i);
            if (mvenue) venue = mvenue[1].toLowerCase();
          } catch (e) { opp = ''; venue = ''; }

          if (!opp) {
            try {
              const gid = g.id != null ? String(g.id) : null;
              if (gid && gamesById && Array.isArray(gamesById[gid])) {
                const teamsForGame = gamesById[gid].filter(tk => tk.toUpperCase() !== teamKeyUpper);
                if (teamsForGame && teamsForGame.length > 0) {
                  opp = teamsForGame[0];
                }
              }
            } catch (e) { /* ignore */ }
          }

          if (opp) {
            if (venue === 'home') {
              display = `${teamStr} vs ${opp}`;
            } else if (venue === 'away') {
              display = `${opp} vs ${teamStr}`;
            } else {
              display = `${teamStr} vs ${opp}`;
            }
            if (datePart) display += `, ${datePart}`;
          } else {
            if (datePart) {
              display = `${teamStr} - ${datePart}`;
            } else {
              display = `${teamStr} - ${g.id || lbl}`;
            }
          }

          opt.textContent = display;
          gameSelect.appendChild(opt);
        });

        // If requested, auto-select the game closest to now without going over.
        try {
          if (autoSelectMostRecent && gameSelect.options.length > 1) {
            const now = Date.now();
            let chosenIdx = -1;
            for (let i = sortedGames.length - 1; i >= 0; --i) {
              const s = (sortedGames[i].start || sortedGames[i].gameDate || (sortedGames[i].label || '').split(' - ')[0] || null);
              const t = s ? Date.parse(s) : NaN;
              if (!isNaN(t) && t <= now) { chosenIdx = i; break; }
            }
            if (chosenIdx === -1) {
              for (let i = 0; i < sortedGames.length; ++i) {
                const s = (sortedGames[i].start || sortedGames[i].gameDate || (sortedGames[i].label || '').split(' - ')[0] || null);
                const t = s ? Date.parse(s) : NaN;
                if (!isNaN(t) && t > now) { chosenIdx = i; break; }
              }
            }
            if (chosenIdx === -1) chosenIdx = sortedGames.length - 1;

            const optIndex = 1 + chosenIdx;
            if (optIndex >= 1 && optIndex < gameSelect.options.length) {
              gameSelect.selectedIndex = optIndex;
              const chosenVal = gameSelect.options[optIndex].value;
              hiddenInput.value = chosenVal;
              manualInput.value = chosenVal;
            }
          }
        } catch (e) { /* ignore auto-selection errors */ }
      }

      teamSelect.addEventListener('change', (e) => { loadGamesForTeam(e.target.value, false); });
      gameSelect.addEventListener('change', (e) => {
        const v = (e.target.value || '').toString().trim();
        hiddenInput.value = v;
        manualInput.value = v;
      });

      manualInput.addEventListener('input', function () {
        try {
          const mv = (this.value || '').trim();
          hiddenInput.value = mv.replace(/\s+/g, '');
          if (mv.length > 0) {
            gameSelect.selectedIndex = 0; // clear selection
          }
        } catch (e) {/* ignore */ }
      });

      form.addEventListener('submit', (e) => {
        const manualVal = (manualInput.value || '').toString().trim();
        const selectVal = (gameSelect.value || '').toString().trim();
        const hiddenVal = (hiddenInput.value || '').toString().trim();
        let finalGame = '';
        if (manualVal !== '') finalGame = manualVal.replace(/\s+/g, '');
        else if (selectVal !== '') finalGame = selectVal.replace(/\s+/g, '');
        else finalGame = hiddenVal.replace(/\s+/g, '');

        if (finalGame === '') {
          e.preventDefault();
          return false;
        }
        hiddenInput.value = finalGame;
      });

      // initial load
      loadStaticTeams();
    })();
  </script>
</body>

</html>